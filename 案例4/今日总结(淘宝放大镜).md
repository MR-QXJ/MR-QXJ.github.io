## 今日总结(淘宝放大镜)

若希望定位时**左边**小图宽高**变**化**不影响右边**定位的元素，可用**right的负值**定位

可先隐藏图片，初始化后再显示，防止图片加载的bug

本案例主要重视各种比例的运用

```
//遮罩新宽/遮罩原宽=缩放后图宽/原图宽   即遮罩新宽 = 缩放后图宽/原图宽*遮罩原宽
 var nmWid = imgArr[index].widPro * 200;
```

```
//遮罩left：鼠标x-图片左偏移-遮罩宽度/2，top同理可得
var minusX = pX - imgLeft - maskWid / 2;
```

```
//遮罩X移动/图片缩放后宽度=大图移动X/大图原宽  即大图移动X=遮罩X移动/图片缩放后宽*大图原宽
var bX = minusX /( imgArr[index].widPro * 400 )* imgArr[index].wid;  //这里的括号不加会bug，估计由于小数计算的误差
```

#### 宽高不等的图片等比例缩放

宽高中最大的一样设置为定值（50），另一样按照比例计算：

```
if(orWid >= orHei){ //宽比高大,设置宽度定值为50
    //原图宽/原图高 = 新宽/新高    即 新高 = 新宽/原图宽*原图高   新宽 = 新高*原图宽/原图高
    $(ele).css({
        "width":  50 +"px",
        "height": 50 / orWid * orHei + "px",
        "top": (50 - 50 / orWid * orHei) / 2 + "px"
    });
    imgArr[i] = {"widPro": 1,"heiPro": orHei / orWid,"wid": orWid,"hei": orHei};/*获取图片宽高和比例*/
}else{ //高比宽大,设置高度定值为50
    $(ele).prop({
        "width":  50 * orWid / orHei,
        "height": 50
    });
    $(ele).css({
        "left": (50 - 50 * orWid / orHei) / 2 + "px"
    });
    imgArr[i] = {"widPro": orWid / orHei,"heiPro": 1,"wid": orWid,"hei": orHei};
}
```

## 昨日总结（全屏滚动）

body，html的高度**默认不是100%**，设置过后子元素才能用100%铺满  

background-**attachment:fixed;**，固定背景，滚动的时候背景像幕布一样拉动  。

**ie**中**外嵌链接的img**图片会自动有一个border，需要清0  

jq里面有**position()**得到一个**对象**，里面有left等属性保存**相当于定位父级**的偏移量  

jq的animate方法不是只能改变css属性，还可以改变**scrollTop等dom**属性  

$(document)是没有scrollTop这个属性的，只能设置给body和html的jq对象:$(“html，body”)  。**html和body都要写**，兼容比如有的游览器没有body。

而jq的**scrollTop()方法**经过封装，**可以**被$("document")直接使用  

$(window).**resize**(fn)当**游览器窗口改变大小**时触发事件  

#### 限制用户滚动频率*

防止用户过于频繁请求数据，浪费性能

##### %降频

声明**数字**变量，每次触发滚轮事件数字变量**累加**，到达**规定数值才执行**效果：

```
var $num = 0;//限制鼠标滚动事件
$(document).mousewheel(function () {
	$num++;
	if($num % 5 === 0) {执行效果}
}
```

##### 开关锁

**声明布尔值**开关初始为true，**滚动时**判断为**true才执行**行为并且**改为false**，本次**执行结束**后再动画**animate**方法的**执行结束回调函数**设置为**true**，这样**后续触发滚轮事件时**前面的动作**若还未执行结束**，布尔值还是false，就**不允许后续**动作：

```
var toggle = true;
   if(toggle){   /*开关锁限制滚动频率*/
              slide(); 执行动作，此函数中有animate方法
   }
    function slide() {
          $bg.stop().animate({
        	  "scrollTop": index * windowH
   },300,function () {    //注意最后这个回调函数动画结束后执行，且会执行两次
          toggle = true;  
          //后续代码
       });
   }
   
   上述代码之所以重新将toggle=true放到animate函数中是因为animate是异步的，动画还没执行完后续代码也会执行，直接在后续代码设置为true则一直都是true，因此要放到animate执行结束的回调函数中，整个动画执行结束后才为true
```

